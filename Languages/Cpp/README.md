



> 해당 페이지에 C++의 기초개념은 다루지 않습니다.  C++를 다루는데 있어 자주 망각할 수 있는 좀 더 본연의 심화적인 내용을 다룹니다.



<br>

<br>



- [C++은 객체지향을 위해 태어난 언어](#C++은-객체지향을-위해-태어난-언어)

- [자료형을 받아드리는 자세](#자료형을-받아드리는-자세)

- [변수 선언 및 정의](#변수-선언-및-정의)

- [auto 예약어](#auto-예약어)

- [참조자에 대한 고찰](#참조자에-대한-고찰)

- [const에 대한 고찰](#const에-대한-고찰)

- [동적 할당에 대한 고찰](#동적-할당에-대한-고찰)

- [namespace에 대한 고찰](#namespace에-대한-고찰)

  

<br>

<br>

<br>



## C++은 객체지향을 위해 태어난 언어

기존 C의 절차지향 체계는 한 사람의 역량이 매우 중요했다. 반면, 객체지향은 협업하는 사람들 간의 관계에 그 이목이 집중된다. 객체지향은 실체와 이상을 분리해서 생각했던 서양철학과 굉장히 닮아 있다. 즉, 객체지향은 `개념적 정의`와 `구현`이 구분되는 것이 가장 큰 특징이다. 이는 다시 말해 `설계`와 `구현`을 분리한다는 뜻이다. 알고보니 C++은 서양의 철학이 고스란히 녹아있는 언어인 것이다.

C++의 객체지향을 이해하기 위해서는 `인스턴스`라는 말에 대한 고찰이 필요하다. 실력자는 `설계` 단계에서 그 진가가 발휘된다. 정확하진 않겠지만 조금은 더 개념적으로 받아드리기 위해 `인스턴스`는 설계로부터 `구현`을 거쳐 선언되어 활용할 수 있는 최종 결과물이라고 받아드리면 될 것 같다. C++은 객체지향이기 때문에 `변수`라는 말보다 `인스턴스`라는 말을 자주 사용하게 된다.

C++를 활용하는 데 요구되는 능력은 곧 설계하거나 혹은 설계된 것을 잘 이해하고 그것을 인스턴스화 시켜 활용하는 능력이다. C++를 받아드릴 때 다음과 같은 사고의 흐름이 습관화 되어야 한다.

C++를 활용하는 데 요구되는 능력은 곧 설계하거나 혹은 설계된 것을 잘 이해하고 그것을 인스턴스화 시켜 활용하는 능력이다. C++를 받아드릴 때 다음과 같은 사고의 흐름이 습관화 되어야 한다.  

> *추상화 &#10140; 설계 &#10140; 구현 &#10140; 인스턴스*



<br>

<br>

<br>



## 자료형을 받아드리는 자세

자료형을 받아드릴 때, 단순히 `int`, `double`과 같이 직관적으로만 받아드리기에는 활용적인 측면에서 한계가 있을 수 있다. 앞으로 자료형을 받아드릴 때는 다음과 같이 받아드리는 것이 좋다.  



> *자료형이란 "일정 크기의 메모리에 저장된 정보를 해석하는 방법을 명시해 놓은 것"*  



C++에는 기존의 C 체계에서는 없는 자료형을 포함하고 있다. `long long`, `auto`, `char16_t`, `char32_t`, `decltype(expr)` 등이 그것이다.



<br>

<br>

<br>



## 변수 선언 및 정의

```c++
int a = 10;		//1
int a(10);		//2
int b(a);		//3
int(10);		//4
```

1번보단 2번 같은 형식이 훨씬 C++스러운 선언 및 정의이다. 2번을 말로 풀어쓴다면 `int 자료형 인스턴스인 a를 선언하고 초기값으로 10을 대입함으로써 a를 정의한다` 정도가 되겠다. 여기서 10은 상수이지만 3번봐 같은 경우는 초기값이 상수가 아니라 변수임을 볼 수 있다. 이는 `b는 a를 원본삼아 그 속의 값을 복제하여 자신을 정의한다` 정도로 풀어 쓸 수 있겠다. 이는 [복사 생성자](#복사-생성자)의 개념으로 이어진다. 4번같은 경우도 가능하다. 단순히 상수를 표현할 수 있는 하나의 방법으로써 int 자료형의 인스턴스를 선언 및 정의했지만 이름이 없는 경우이다. 쓸일은 없겠지만 C++의 객체지향 개념을 잘 나타내는 구문이다.



<br>

<br>

<br>



## auto 예약어

기존 C의 auto 예약어는 지역 변수 (자동 변수)선언에 해당되는 기억 분류 지정자였다. 하지만 생략하면 자동으로 지역변수로 선언이 되기 때문에 아무도 사용하지 않았습니다. C++11로 넘어오면서 그 기능이 새로워졌다. auto 예약어의 기능은 다음과 같이 핵심만 기억하면 된다

> *초깃값의 형식에 맞춰 선언하는 인스턴스의 형식을 '자동'으로 결정하는 예약어*

```c++
void testFunc(char, int){}

int main() {
    // 여기서 함수 포인터의 형태는 기본 형식에 포인터 변수를 선언할 때를 생각해 보면 된다.
    void(*pTestFunc1)(char, int) = testFunc;	//1
    auto pTestFunc2(testFunc);					//2
    pTestFunc2('A', 1);
    return 0;
}
```

기존의 C언어에서는 1번과 같이 함수 형식을 모두 맞춰주어야 했다. 하지만 2번과 같이 `pTestFunc2` 선언된 인스턴스 형식을 `testFunc`이라는 주솟값을 대입함으로써 auto가 `pTestFunc2`의 인스턴스 형식을 자동으로 지정해주었다.  즉 auto는 복제하고자 하는 원본 형식을 따라간다.

[auto 예약어 심화(예정)]()



<br>

<br>

<br>



## 참조자에 대한 고찰

두괄식으로 얘기하자면, **참조자는 변하지 않는 포인터이다.** 참조자에 대해 알아보기 전에 C언어에서의 포인터에 대한 개념을 짚고 넘어갈 필요가 있다.

```c++
int num = 10;
int *pNum = &num;	// 포인터
int &rNum = num;	// 참조자
```

이같이 C언어에서 포인터는 `주소`를 담는 변수로써 역할을 한다. 그렇다면 C++이 생기면서 그냥 포인터를 쓰면 될 것을 왜 굳이 참조자를 만들었을까? 참조자는 기존 C에서 사용하던 포인터의 치명적인 문제점을 개선하고자 만들어진 개념이다. 그렇다면 기존의 C언어의 포인터가 가지고 있던 고질적인 문제점에 대해서 먼저 알아보자

<br>

### 기존 포인터가 가졌던 치명적인 단점

1. 포인터가 `NULL`을 가리킬 수 있다. 즉, 초기화되지 않는 `null pointer exception`이나 `segmentation fault`와 같은 예외사항을 발생시킬 가능성을 항상 내포하고 있다.

   ```c++
   int *p;	// 정의하지 않은 상태로 p를 사용
   ```

2. 포인터는 일종의 `변수`로써 값이 변할 수 있는 가능성을 가지고 있다. 이는 프로그래머가 실수할 가능성을 높인다.

   ```c++
   int a = 10;
   int *p = &a;
   cout << *p; // result: 10
   int b = 20;
   p = &b;
   cout << *p;	// result: 20
   ```

3. 이는 가리킬 대상을 포인터에 할당할 때, 주소값을 할당함으로써 비롯되는 문제들이다.  



이와같은 포인터의 변절자적인 면모는 지금껏 많은 C언어 프로그래머들을 괴롭혀왔다. 아무리 뛰어난 실력자라도 인간이라면 실수를 하기 마련이고, 그 실수는 시스템의 치명적인 결함을 초래하기도 했다. 때문에 개발자들은 자유도가 높은 포인터의 강력한 기능은 그대로 유지하면서 위와 같은 치명적인 단점을 방지할 수 있는 방안을 고안해냈는데 그것이 바로 참조자이다.

> *참조자는 포인터의 강력함을 유지하면서 단점만 극복하기 위해 고안된 것이다.*  

<br>

### 포인터의 단점을 극복한 참조자

이제 참조자의 존재 이유에 대해 알게 되었다. 그렇다면 참조자는 어떤 제약조건을 통해 위와 같은 포인터의 단점을 극복할 수 있었을까?

1. 참조자를 선언할 때는 반드시 동시에 초기화(정의)를 시켜주어야만 한다. 참조자는 기존의 변수에 별명을 부여하는 것이다. 별명을 부여할 대상이 없으면 이는 무의미한 것이다.

   ```c++
   int a = 10;
   int &ra = a;	// 가능
   int &ra;		// 
   ra = a;			// 불가능
   ```

   위와 같이 선언과 동시에 초기화를 시켜줌으로써 `null pointer exception`과 같은 예외사항의 가능성을 사전에 차단해버렸다.

2. 참조자는 한번 초기화하면 바꿀 수 없다.

   ```c++
   int a = 10;
   int &ra = 10;
   int b = 20;
   ra = b			// 불가능
   ```

   이를 통해 위에서 언급한 포인터의 두번 째 단점을 극복할 수 있었다. 참조자의 이같은 기능은 사실 다음과 같은 형태의 포인터로부터 비롯되었다.

   ```c++
   const int *p = &a;	// p가 가리키는 a를 상수화
   int* const p = &a;	// a의 주소가 들어있는 포인터 변수 p를 상수화
   ```

   C프로그래머들은 위에서 언급한 포인터의 값 변질이라는 단점을 극복하기 위해 두 번째 형태와 같은 포인터를 즐겨 썼다. C++에서 바로 두 번째 형태의 포인터를 문법화 시킨 것이 바로 참조자인 것이다.

3. 초기화를 할 때, 주소 값이 아닌 변수 자체를 대입.

   ```c++
   int a = 10;
   int &ra = a;
   ```

   여기에는 사실 조금 더 복잡한 의미가 담겨있다. 참조자는 포인터 변수와는 다르게 메모리 공간을 할당 받지 않는다. 위의 구문이 컴파일될 때 `ra` 참조자는 자신이 참조하고 있던  `a`변수의 **실제 주소 값으로 대체**된다. 즉, 애초에 `a`변수의 주소 값을 저장할 공간이 필요 없는 것이다.

그렇다면 앞으로 참조자를 다룰 때 어떤 사고와 함께 다루어야 할 것인가? 

**첫째로**, 실수를 하지 않기 위해 참조자를 쓴다. C의 포인터로 인한 치명적 결함을 미연에 방지하고자 한 것이니 값을 직접 다룰 예정이라면 고민하지 않고 참조자를 쓰는 것이 옳다. 

**둘째로**, 참조자를 다룰 때는 반드시 기존 원본과의 연결성을 고려해야 한다. 위의 3번 같이 컴파일러에 의해 실제 참조 원본의 주소값으로 대체되는 것을 유념하면서 써야한다.

<br>

### 참조자의 배열과 배열의 참조자

얼핏 헷갈릴 수 있는 개념이다. 참조자의 배열은 말그래도 참조자 형식의 배열을 의미한다. 이는 과연 가능한가?

```c++
int a, b;
int &arr[2] = {a, b};
```

결과부터 얘기하자면 이는 불가능하다. 이를 컴파일 하면 다음과 같은 에러 문구가 뜬다.

```c++
error C2234: 'arr' : arrays of references are illegal
```

**레퍼런스의 레퍼런스,레퍼런스의 배열, 레퍼런스의 포인터는 존재할 수 없다**. 여기에는 지금까지 설명했던 참조자의 근원적 개념과 밀접한 관련이 있다. 먼저 `int arr[10]`과 같은 배열에서 `arr`은 다름아닌 배열의 첫번째 요소를 가리키는 `주소`이다. 그리고 주소를 담을 수 있는 변수는 바로 `포인터`이다. 그런데 전에 살펴 보았듯, **참조자는 메모리의 공간을 갖지 않는다.** 즉, `int &arr[2]`라는 구문은 존재 자체에서 부터 `모순`이 발생한 것이다.

반면 배열의 참조자는 어떻게 선언 및 정의할 수 있을까? 다음과 같이 배열에 대한 참조자를 만들 수 있다.

```c++
int arr[2] = {1, 2};
int (&rArr)[2] = arr;
```

다만 이런 식으로 배열에 대한 참조자를 생성할 경우, 배열의 고정된 길이를 알아야 하므로 효용성이 다소 떨어진다. 배열을 다룰 땐 참조자 보단 포인터를 사용하는 것이 더 권장된다.

<br>

참고로 다음과 같은 연산은 어떤식으로 되는지 알아두자

```c++
int *a = 1;
a++;
```

먄약 a의 주소가 `0x00ff00`이었다면 `a++`의 연산을 실행한 이후에 `a`는 `int`자료형은 `4byte`이므로 주소가 4만큼 이동한 `0x00ff04`가 될 것이다. 이는 위의 [자료형을 받아드리는 자세](#자료형을-받아드리는-자세)에서 설명했던 것과 같이 `a`도 `int`를 가리키는 포인터인 자료형으로 선언된 인스턴스이기 때문이다. 즉, `a++`라는 연산을 시행하면 `a`의 자료형에 맞는 연산을 실행하는 것.



<br>

<br>

<br>



## const에 대한 고찰









<br>

<br>

<br>



## 동적 할당에 대한 고찰









<br>

<br>

<br>



## namespace에 대한 고찰









