



> 해당 페이지에 C++의 기초개념은 다루지 않습니다.  C++를 다루는데 있어 자주 망각할 수 있는 좀 더 본연의 심화적인 내용을 다룹니다.



<br>

<br>



- [C++은 객체지향을 위해 태어난 언어](#C++은-객체지향을-위해-태어난-언어)

- [자료형을 받아드리는 자세](#자료형을-받아드리는-자세)

- [변수 선언 및 정의](#변수-선언-및-정의)

- [auto 예약어](#auto-예약어)

- [참조자에 대한 고찰](#참조자에-대한-고찰)

- [const에 대한 고찰](#const에-대한-고찰)

- [동적 할당에 대한 고찰](#동적-할당에-대한-고찰)

- [namespace에 대한 고찰](#namespace에-대한-고찰)

  

<br>

<br>

<br>



## C++은 객체지향을 위해 태어난 언어

기존 C의 절차지향 체계는 한 사람의 역량이 매우 중요했다. 반면, 객체지향은 협업하는 사람들 간의 관계에 그 이목이 집중된다. 객체지향은 실체와 이상을 분리해서 생각했던 서양철학과 굉장히 닮아 있다. 즉, 객체지향은 `개념적 정의`와 `구현`이 구분되는 것이 가장 큰 특징이다. 이는 다시 말해 `설계`와 `구현`을 분리한다는 뜻이다. 알고보니 C++은 서양의 철학이 고스란히 녹아있는 언어인 것이다.

C++의 객체지향을 이해하기 위해서는 `인스턴스`라는 말에 대한 고찰이 필요하다. 실력자는 `설계` 단계에서 그 진가가 발휘된다. 정확하진 않겠지만 조금은 더 개념적으로 받아드리기 위해 `인스턴스`는 설계로부터 `구현`을 거쳐 선언되어 활용할 수 있는 최종 결과물이라고 받아드리면 될 것 같다. C++은 객체지향이기 때문에 `변수`라는 말보다 `인스턴스`라는 말을 자주 사용하게 된다.

C++를 활용하는 데 요구되는 능력은 곧 설계하거나 혹은 설계된 것을 잘 이해하고 그것을 인스턴스화 시켜 활용하는 능력이다. C++를 받아드릴 때 다음과 같은 사고의 흐름이 습관화 되어야 한다.

C++를 활용하는 데 요구되는 능력은 곧 설계하거나 혹은 설계된 것을 잘 이해하고 그것을 인스턴스화 시켜 활용하는 능력이다. C++를 받아드릴 때 다음과 같은 사고의 흐름이 습관화 되어야 한다.  

> *추상화 &#10140; 설계 &#10140; 구현 &#10140; 인스턴스*



<br>

<br>

<br>



## 자료형을 받아드리는 자세

자료형을 받아드릴 때, 단순히 `int`, `double`과 같이 직관적으로만 받아드리기에는 활용적인 측면에서 한계가 있을 수 있다. 앞으로 자료형을 받아드릴 때는 다음과 같이 받아드리는 것이 좋다.  



> *자료형이란 "일정 크기의 메모리에 저장된 정보를 해석하는 방법을 명시해 놓은 것"*  



C++에는 기존의 C 체계에서는 없는 자료형을 포함하고 있다. `long long`, `auto`, `char16_t`, `char32_t`, `decltype(expr)` 등이 그것이다.



<br>

<br>

<br>



## 변수 선언 및 정의

```c++
int a = 10;		//1
int a(10);		//2
int b(a);		//3
int(10);		//4
```

1번보단 2번 같은 형식이 훨씬 C++스러운 선언 및 정의이다. 2번을 말로 풀어쓴다면 `int 자료형 인스턴스인 a를 선언하고 초기값으로 10을 대입함으로써 a를 정의한다` 정도가 되겠다. 여기서 10은 상수이지만 3번봐 같은 경우는 초기값이 상수가 아니라 변수임을 볼 수 있다. 이는 `b는 a를 원본삼아 그 속의 값을 복제하여 자신을 정의한다` 정도로 풀어 쓸 수 있겠다. 이는 [복사 생성자](#복사-생성자)의 개념으로 이어진다. 4번같은 경우도 가능하다. 단순히 상수를 표현할 수 있는 하나의 방법으로써 int 자료형의 인스턴스를 선언 및 정의했지만 이름이 없는 경우이다. 쓸일은 없겠지만 C++의 객체지향 개념을 잘 나타내는 구문이다.



<br>

<br>

<br>



## auto 예약어

기존 C의 auto 예약어는 지역 변수 (자동 변수)선언에 해당되는 기억 분류 지정자였다. 하지만 생략하면 자동으로 지역변수로 선언이 되기 때문에 아무도 사용하지 않았습니다. C++11로 넘어오면서 그 기능이 새로워졌다. auto 예약어의 기능은 다음과 같이 핵심만 기억하면 된다

> *초깃값의 형식에 맞춰 선언하는 인스턴스의 형식을 '자동'으로 결정하는 예약어*

```c++
void testFunc(char, int){}

int main() {
    // 여기서 함수 포인터의 형태는 기본 형식에 포인터 변수를 선언할 때를 생각해 보면 된다.
    void(*pTestFunc1)(char, int) = testFunc;	//1
    auto pTestFunc2(testFunc);					//2
    pTestFunc2('A', 1);
    return 0;
}
```

기존의 C언어에서는 1번과 같이 함수 형식을 모두 맞춰주어야 했다. 하지만 2번과 같이 `pTestFunc2` 선언된 인스턴스 형식을 `testFunc`이라는 주솟값을 대입함으로써 auto가 `pTestFunc2`의 인스턴스 형식을 자동으로 지정해주었다.  즉 auto는 복제하고자 하는 원본 형식을 따라간다.

[auto 예약어 심화(예정)]()



<br>

<br>

<br>



## 참조자에 대한 고찰

두괄식으로 얘기하자면, **참조자는 변하지 않는 포인터이다.** 참조자에 대해 알아보기 전에 C언어에서의 포인터에 대한 개념을 짚고 넘어갈 필요가 있다.

```c++
int num = 10;
int *pNum = &num;	// 포인터
int &rNum = num;	// 참조자
```

이같이 C언어에서 포인터는 `주소`를 담는 변수로써 역할을 한다. 그렇다면 C++이 생기면서 그냥 포인터를 쓰면 될 것을 왜 굳이 참조자를 만들었을까? 참조자는 기존 C에서 사용하던 포인터의 치명적인 문제점을 개선하고자 만들어진 개념이다. 그렇다면 기존의 C언어의 포인터가 가지고 있던 고질적인 문제점에 대해서 먼저 알아보자

<br>

### 기존 포인터가 가졌던 치명적인 단점

1. 포인터가 `NULL`을 가리킬 수 있다. 즉, 초기화되지 않는 `null pointer exception`이나 `segmentation fault`와 같은 예외사항을 발생시킬 가능성을 항상 내포하고 있다.

   ```c++
   int *p;	// 정의하지 않은 상태로 p를 사용
   ```

2. 포인터는 일종의 `변수`로써 값이 변할 수 있는 가능성을 가지고 있다. 이는 프로그래머가 실수할 가능성을 높인다.

   ```c++
   int a = 10;
   int *p = &a;
   cout << *p; // result: 10
   int b = 20;
   p = &b;
   cout << *p;	// result: 20
   ```

3. 이는 가리킬 대상을 포인터에 할당할 때, 주소값을 할당함으로써 비롯되는 문제들이다.  



이와같은 포인터의 변절자적인 면모는 지금껏 많은 C언어 프로그래머들을 괴롭혀왔다. 아무리 뛰어난 실력자라도 인간이라면 실수를 하기 마련이고, 그 실수는 시스템의 치명적인 결함을 초래하기도 했다. 때문에 개발자들은 자유도가 높은 포인터의 강력한 기능은 그대로 유지하면서 위와 같은 치명적인 단점을 방지할 수 있는 방안을 고안해냈는데 그것이 바로 참조자이다.

> *참조자는 포인터의 강력함을 유지하면서 단점만 극복하기 위해 고안된 것이다.*  

<br>

### 포인터의 단점을 극복한 참조자

이제 참조자의 존재 이유에 대해 알게 되었다. 그렇다면 참조자는 어떤 제약조건을 통해 위와 같은 포인터의 단점을 극복할 수 있었을까?

1. 참조자를 선언할 때는 반드시 동시에 초기화(정의)를 시켜주어야만 한다. 참조자는 기존의 변수에 별명을 부여하는 것이다. 별명을 부여할 대상이 없으면 이는 무의미한 것이다.

   ```c++
   int a = 10;
   int &ra = a;	// 가능
   int &ra;		// 
   ra = a;			// 불가능
   ```

   위와 같이 선언과 동시에 초기화를 시켜줌으로써 `null pointer exception`과 같은 예외사항의 가능성을 사전에 차단해버렸다.

2. 참조자는 한번 초기화하면 바꿀 수 없다.

   ```c++
   int a = 10;
   int &ra = 10;
   int b = 20;
   ra = b			// 불가능
   ```

   이를 통해 위에서 언급한 포인터의 두번 째 단점을 극복할 수 있었다. 참조자의 이같은 기능은 사실 다음과 같은 형태의 포인터로부터 비롯되었다.

   ```c++
   const int *p = &a;	// p가 가리키는 a를 상수화
   int* const p = &a;	// a의 주소가 들어있는 포인터 변수 p를 상수화
   ```

   C프로그래머들은 위에서 언급한 포인터의 값 변질이라는 단점을 극복하기 위해 두 번째 형태와 같은 포인터를 즐겨 썼다. C++에서 바로 두 번째 형태의 포인터를 문법화 시킨 것이 바로 참조자인 것이다.

3. 초기화를 할 때, 주소 값이 아닌 변수 자체를 대입.

   ```c++
   int a = 10;
   int &ra = a;
   ```

   여기에는 사실 조금 더 복잡한 의미가 담겨있다. 참조자는 포인터 변수와는 다르게 메모리 공간을 할당 받지 않는다. 위의 구문이 컴파일될 때 `ra` 참조자는 자신이 참조하고 있던  `a`변수의 **실제 주소 값으로 대체**된다. 즉, 애초에 `a`변수의 주소 값을 저장할 공간이 필요 없는 것이다.

그렇다면 앞으로 참조자를 다룰 때 어떤 사고와 함께 다루어야 할 것인가? 

**첫째로**, 실수를 하지 않기 위해 참조자를 쓴다. C의 포인터로 인한 치명적 결함을 미연에 방지하고자 한 것이니 값을 직접 다룰 예정이라면 고민하지 않고 참조자를 쓰는 것이 옳다. 

**둘째로**, 참조자를 다룰 때는 반드시 기존 원본과의 연결성을 고려해야 한다. 위의 3번 같이 컴파일러에 의해 실제 참조 원본의 주소값으로 대체되는 것을 유념하면서 써야한다.

<br>

### 참조자의 배열과 배열의 참조자

얼핏 헷갈릴 수 있는 개념이다. 참조자의 배열은 말그래도 참조자 형식의 배열을 의미한다. 이는 과연 가능한가?

```c++
int a, b;
int &arr[2] = {a, b};
```

결과부터 얘기하자면 이는 불가능하다. 이를 컴파일 하면 다음과 같은 에러 문구가 뜬다.

```c++
error C2234: 'arr' : arrays of references are illegal
```

**레퍼런스의 레퍼런스,레퍼런스의 배열, 레퍼런스의 포인터는 존재할 수 없다**. 여기에는 지금까지 설명했던 참조자의 근원적 개념과 밀접한 관련이 있다. 먼저 `int arr[10]`과 같은 배열에서 `arr`은 다름아닌 배열의 첫번째 요소를 가리키는 `주소`이다. 그리고 주소를 담을 수 있는 변수는 바로 `포인터`이다. 그런데 전에 살펴 보았듯, **참조자는 메모리의 공간을 갖지 않는다.** 즉, `int &arr[2]`라는 구문은 존재 자체에서 부터 `모순`이 발생한 것이다.

반면 배열의 참조자는 어떻게 선언 및 정의할 수 있을까? 다음과 같이 배열에 대한 참조자를 만들 수 있다.

```c++
int arr[2] = {1, 2};
int (&rArr)[2] = arr;
```

다만 이런 식으로 배열에 대한 참조자를 생성할 경우, 배열의 고정된 길이를 알아야 하므로 효용성이 다소 떨어진다. 배열을 다룰 땐 참조자 보단 포인터를 사용하는 것이 더 권장된다.

<br>

참고로 다음과 같은 연산은 어떤식으로 되는지 알아두자

```c++
int *a = 1;
a++;
```

먄약 a의 주소가 `0x00ff00`이었다면 `a++`의 연산을 실행한 이후에 `a`는 `int`자료형은 `4byte`이므로 주소가 4만큼 이동한 `0x00ff04`가 될 것이다. 이는 위의 [자료형을 받아드리는 자세](#자료형을-받아드리는-자세)에서 설명했던 것과 같이 `a`도 `int`를 가리키는 포인터인 자료형으로 선언된 인스턴스이기 때문이다. 즉, `a++`라는 연산을 시행하면 `a`의 자료형에 맞는 연산을 실행하는 것.



<br>

<br>

<br>



## const에 대한 고찰

`const`는 일종의 `이름이 있는 상수` 이며 반드시 선언과 함께 `초기화`를 시켜주어야한다. `const`가 붙은 변수는 이후에 프로그램에 의해 변경될 수 없다. 지금까지 이정도로는 알고 있다. 다들 그럴 것이다.

하지만 프로그래밍을 하다보면 `cosnt`라는 녀석이 괴롭히는 경우가 심심치 않게 발생한다. 반환형이 `const`가 아니라는 이유로 컴파일이 안되기도 하고, 여튼 컴파일 오류에서 많은 경우 `const`가 등장한다. 앞으로도 그럴 것이다. 하지만 그럴 때마다 `const`에 겁먹지 않고 손쉽게 문제를 해결할 수 있길 바란다.

```c++
prog.cpp: In function ‘int main()’:
prog.cpp:41:37: error: invalid conversion from ‘const int*’ to ‘int*’ [-fpermissive]
  int * const parr = testClass.getArr(nothing);
                     ~~~~~~~~~~~~~~~~^~~~~~~~~
```

정말 짜증나지 않을 수 없다!

<br>

### `const`의 존재 이유

C와 C++에서 `const`는 변수의 값이 바뀌는 것을 방지하기 위해 태어났다. 원래는 `readonly` 라고 불렸다. 아무리 노력해도 값이 의도치 않게 변하는 현상으로 인해 프로그램에 심각한 결함이 이따금 발생했고, 적어도 값의 변질로 인한 결함 만큼은 피하고 싶어했다. 그래서 컴파일러에게 "앞으로 이 값은 어떤 일이 있어도 절대 바꾸지마! 만약 누가 바꾸려고 하면 아예 컴파일 자체를 하지마!"라고 명시를 해주는데 그것이 바로 `const`인 것이다. `const`는 일종의 난간이라고 생각하면 쉽다. 프로그램에서 일종의 `안전장치`인 것이다. 앞으로 `const`를 만나면 다음과 같은 마음가짐을 갖도록 하자.

> *"코드 제공자가 이 값은 절대 안바뀌게 하고 싶었구나!"*
>
> *"컴파일에게 값이 변하지 않을 것이라 확신을 시켜줘야 겠구나!"*

<br>

### 상황별 `const`의 쓰임

```c++
const int* const Method(const int* const pointer) const;
//1          2            3          4              5
```

이게 무슨 해괴망측한 함수인가 싶겠지만 절망스럽게도 컴파일시 전혀 문제가 없는 함수이다. 위 다섯개의 `const`는 각기의 위치에서 자신 만의 안정창치를 설치한다. 목표는 위 함수를 완전하게 이해하고 활용할 수 있는 것. 저런 망측한 함수를 만나도 절대 쫄지 않는 것이다.

#### 1. `const int * const Method()`

1번 위치와 2번 위치의 `const`는 함수로부터 반환되는 데이터에 대한 한정자다. 1번은 반환되는 값을 변경할 수 없게끔 한다. 당연히 반환되는 데이터를 담을 자료형에 `const`를 붙여주어야 한다. 그렇지 않으면 컴파일 오류가 뜬다.

```c++
const int * const func()
{
	int *parr = new int[3];
	return parr;
}
int * np = new int[3];
const int *p1 = func(); // 앞에 const를 붙여야 할당 가능
p1 = np; // 가능
const int const *p2 = func();
p2 = np; // 불가능
```

하지만 2번 위치의 `const`가 이론과는 다소 다른 행태를 보인다. 원래는 반환된 포인터가 변경될 수 없어야 하는게 위치상 의미가 통하지만, 위의 예제를 보는 것과 같이, p1에 다른 포인터 변수 값을 대입해도 컴파일 오류가 전혀 일어나지 않는다. 대신 `p2` 처럼 포인터 변수 앞에 다시 `const`를 붙일 경우, 원하는 결과가 나온다. 이 부분은 좀 더  연구를 해야할 듯 하다.

#### 2. `int * Method(const int* const pointer)`

```c++
void func1(const int * const input)
{
    int a = input[0];	// 가능
    input = new int[3];	// 불가능
    input[0] = 10;		// 불가능
}

int main() {
    int * np = new int[2];
    np[0] = 1;
    np[1] = 2;
    const int *p = func(np);
    return 0;
}
```

이건 쉽다. 함수의 입력값으로 들어오는 매개변수에 대한 조작을 불허하는 한정 위치다.

#### 3. `int * Method() const`

이건 일반적인 함수에는 쓰일 수 없는 한정어 위치이다. 오로지 `클래스` 내의 `멤버 함수`에서만 가능한 문법이다. 해당 함수 내에서 생성된 객체의 어떤 `멤버 변수`도 변형시킬 수 없다. 참고로 `객체 = 데이터 덩어리`라고 볼 수도 있다. 실제로 인스턴스에 대해 `sizeof()` 연산을 시행할 경우, 멤버변수 합만큼의 크기가 나온다. 여튼, 오브젝트 조작을 허용하지 않는다. 주로 `get`함수에서 많이 쓴다.

```c++
class TestClass
{
public:
    const int data;
    TestClass():data(10){};
    int getData() const{ 
        data = 30;	// 불가
        return data;
    }
};
```

`get`함수에선 습관적으로 쓰도록 하자.

<br>

### `const`와 참조자

```c++
void Subroutine4(big_structure_type const &Parameter1);
```
만약 매개변수로 들어오는 값의 덩치가 크다면 아마도 `call by reference`를 활용함으로써 포인터 변수를 넘겨줄 것이다. 하지만 `C++`에서는 포인터는 배열 다룰 때를 제외하고는 가급적 쓰지 않는 것이 좋다. 더 좋은 참조자가 있지 않은가? 포인터 변수 또한 주소 값을 복사해서 서브루틴의 자동변수로 넘겨준다. 하지만 위의 예시와 같이 `const 참조자` 를 통해 넘겨준다면 해당 값을 복사하지 않아도 되고, 서브 루틴에서의 입력값에 대한 의도치 않은 변경 또한 방지할 수 있다. 다음과 같은 사항을 기억하자.

> *입력값으로 들어오는 매개변수를 조작하지 않는 서브 루틴, 즉 입력값을 `참고`만 해서 로직을 실행시켜야 할 경우, 입력 형식이 아닌 이상 매개변수로 `const &Param`을 쓰도록 하자.*

<br>

### 우리가 자꾸만 `const` 에러를 만나는 이유

```c++
const int * const_arr = new int[3];
int * general_arr = new int[3];

const int * i_am_const = general_arr;	// 1. 가능	
int * i_am_general = const_arr;			// 2. 불가능
```

어떤 패턴이 있는지 유심시 살펴보자. 아래의 예시도 컴파일 오류가 나는 코드이다.

```c++
class TestClass {
public:
	const int data;

	TestClass(int input): data(input){};

	const void transData() const {
		getData();	// 3. 불가능
	}
	
	int getData()	// 만약 여기에 const 한정어가 붙는다면 위의 transData() 가능
    {return data;}
};
```

위의 경우와 어떤 공통점이 있는지 살펴 보는 것이 중요하다. 먼저 1번 경우를 살펴보자. `const` 한정어를 붙인 변수에 `일반 변수`는 복제 대입이 가능하다. 하지만 2번의 경우, `일반 변수`에 `const` 한정어가 붙은 변수를 대입하니 컴파일 오류가 발생했다. 3번의 경우도 마찬가지이다. `const` 한정어가 붙은 멤버 함수 안에서 `일반 함수`를 호출했더니 컴파일 오류가 발생했다. 우리는 여기서 한가지 중요한 원칙을 발견할 수 있다.

> *해당 연산을 통해 기존에 지키고자(변경불가로 만들고자) 했던 변수에 **변경 가능성**이 생겨버리면 컴파일 오류를 발생시킨다!*

1번의 경우, `i_am_const`가 우리가 다루는 `left` 변수이고 우리는 이 변수를 다룬다고 해서 목표 지점의 데이터를 여전히 바꿀 수 없다. 하지만 2번의 경우, `i_am_general` 변수에 `const_arr`가 가지고 있던 주소값이 전달이 된다면, 컴파일은 `i_am_general`에 `const`한정어가 붙어있지 않기 때문에, "어? 이 포인터가 가리키는 값은 바꿀 수 있구나?" 라고 인식하게 된다. 그럼 마지막 3번 경우를 보자, `transData()`라는 함수는 멤버 변수를 변경할 수 없다. 하지만 `getData()`라는 일반 멤버 함수는 `const`의 한정어가 붙어 있지 않으므로 `멤버 변수 변경 가능`의 `가능성`이 있기 때문에 애초에 컴파일 오류를 발생시키는 것이다. 위의 `원칙`과 함께 다음 하나만 더 기억하자. `const` 함수에선 `const`만 다룰 수 있다는 건 다음의 이유에서이다.

> *내가(호출자가) 바꿀 수 없는건 너도(피호출자 함수)도 바꿀 수 없다. 즉, 너는 반드시 바꾸지 않을 것이라는 계약서(const 한정어)를 작성해야만 나와 일할 수 있다.*

<br>

### `const` 멤버 변수를 초기화할 때 (이니셜라이저, 멤버초기화리스트)

```c++
class TestClass {
public:
	const int data;
	const int *arr;
	
	TestClass(int input, int* parr): data(input), arr(parr){};
};
```

`멤버이니셜라이저(멤버초기화리스트)`는 **객체를 생성하기 이전에 멤버변수를 초기화** 한다. `생성자`의 내부로직은 객체가 생성된 이후에 멤버변수를 초기화한다. 하지만 알다시피 `const`는 선언과 동시에 정의를 해주어야만 한다. 객체가 생성되었다는 것은 멤버변수가 선언되었다는 것인데, 선언 이후에 `생성자`의 내부 로직에서 `const` 변수를 정의를 해준다는 것은 `const`의 문법과 충돌하는 것이다. 실수하기 매우 쉬운 구간이니 잘 기억하고 있도록 하자.

> `const 멤버 변수 초기화`는 `생성자 내부`가 아닌 `멤버초기화리스트`에서!

<br>

[참고자료1 (eng)](http://duramecho.com/ComputerInformation/WhyHowCppConst.html)

[참고자료2 (kor)](https://thrillfighter.tistory.com/214)

<br>

<br>

<br>



## 동적 할당에 대한 고찰









<br>

<br>

<br>



## namespace에 대한 고찰









